// with help from https://valeriomarty.medium.com/raymarched-volumetric-lighting-in-unity-urp-e7bc84d31604
#pragma kernel Upsample

#include "UnityCG.cginc"
//find better way to determine number of threads
static const int sqrtThreads = 32;

Texture2D<float4> _BaseTexture;
Texture2D<float> _CameraDepthTexture;
Texture2D<float> _CameraDepthTextureDownsampled;
RWTexture2D<float4> _OutputTexture;

const int _upsampleRatio;

const int2 _textureSize;

[numthreads(sqrtThreads, sqrtThreads, 1)]
void Upsample(int2 id : SV_DispatchThreadID)
{
    if (id.x >= _textureSize.x || id.y >= _textureSize.y)
    {
        return;
    }
    
    float4 color = float4(0, 0, 0, 0);
    
    int offset = 0;
    //float d0 = _CameraDepthTexture[id.xy].r;
    float d0 = LinearEyeDepth(_CameraDepthTexture[id.xy].r);

    int2 downsampleNeighborhood = int2(id.xy) / _upsampleRatio;
    int2 downsampledTextureSize = _textureSize / _upsampleRatio;
    int2 downsamplePixels[5] =
    {
        clamp(downsampleNeighborhood + int2(0, 0), 0, downsampledTextureSize - 1),
        clamp(downsampleNeighborhood + int2(0, 1), 0, downsampledTextureSize - 1),
        clamp(downsampleNeighborhood + int2(0, -1), 0, downsampledTextureSize - 1),
        clamp(downsampleNeighborhood + int2(1, 0), 0, downsampledTextureSize - 1),
        clamp(downsampleNeighborhood + int2(-1, 0), 0, downsampledTextureSize - 1)
        //clamp(downsampleNeighborhood + int2(0, 0), 0, downsampledTextureSize - 1),
        //clamp(downsampleNeighborhood + int2(0, 1), 0, downsampledTextureSize - 1),
        //clamp(downsampleNeighborhood + int2(1, 0), 0, downsampledTextureSize - 1),
        //clamp(downsampleNeighborhood + int2(1, 1), 0, downsampledTextureSize - 1)
    };
    
    //float d1 = _CameraDepthTextureDownsampled[downsamplePixels[0]].r;
    //float d2 = _CameraDepthTextureDownsampled[downsamplePixels[1]].r;
    //float d3 = _CameraDepthTextureDownsampled[downsamplePixels[2]].r;
    //float d4 = _CameraDepthTextureDownsampled[downsamplePixels[3]].r;
    //float d5 = _CameraDepthTextureDownsampled[downsamplePixels[4]].r;
    
    float d1 = LinearEyeDepth(_CameraDepthTextureDownsampled[downsamplePixels[0]].r);
    float d2 = LinearEyeDepth(_CameraDepthTextureDownsampled[downsamplePixels[1]].r);
    float d3 = LinearEyeDepth(_CameraDepthTextureDownsampled[downsamplePixels[2]].r);
    float d4 = LinearEyeDepth(_CameraDepthTextureDownsampled[downsamplePixels[3]].r);
    float d5 = LinearEyeDepth(_CameraDepthTextureDownsampled[downsamplePixels[4]].r);

    d1 = abs(d0 - d1);
    d2 = abs(d0 - d2);
    d3 = abs(d0 - d3);
    d4 = abs(d0 - d4);
    d5 = abs(d0 - d5);
    //d1 = distance(d0, d1);
    //d2 = distance(d0, d2);
    //d3 = distance(d0, d3);
    //d4 = distance(d0, d4);
    //d5 = distance(d0, d5);
    
    float dmin = min(min(min(d1, d2), min(d3, d4)), d5);
    
    if (dmin == d1)
        offset = 0;
    else if (dmin == d2)
        offset = 1;
    else if (dmin == d3)
        offset = 2;
    else if (dmin == d4)
        offset = 3;
    else if (dmin == d5)
        offset = 4;
    
    switch (offset)
    {
        case 0:
            color = _BaseTexture[downsamplePixels[0]];
            break;
        case 1:
            color = _BaseTexture[downsamplePixels[1]];
            break;
        case 2:
            color = _BaseTexture[downsamplePixels[2]];
            break;
        case 3:
            color = _BaseTexture[downsamplePixels[3]];
            break;
        case 4:
            color = _BaseTexture[downsamplePixels[4]];
            break;
        default:
            color = _BaseTexture[downsampleNeighborhood];
            break;
    }
    
    _OutputTexture[id.xy] = color;
}